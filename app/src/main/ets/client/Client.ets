import { Device } from '../entity/Device';
import { ClientStream } from './tools/ClientStream';
import { VideoDecoder } from './decode/VideoDecoder';
import { AudioDecoder } from './decode/AudioDecoder';
import { ControlPacket, Action, TouchAction, KeyCode } from './tools/ControlPacket';
import pasteboard from '@ohos.pasteboard';
import { util } from '@kit.ArkTS';
import { common } from '@kit.AbilityKit';

// è§†é¢‘é…ç½®æ¥å£
// è§†é¢‘é…ç½®æ¥å£ï¼ˆä½¿ç”¨ClientStreamä¸­çš„å®šä¹‰ï¼‰
import { VideoConfig } from './tools/ClientStream';

// å®¢æˆ·ç«¯ç®¡ç†å™¨
export class Client {
  private static allClients: Map<string, Client> = new Map();
  private device: Device;
  private clientStream?: ClientStream;
  private videoDecoder?: VideoDecoder;
  private isClosed: boolean = false;
  private keepAliveTimer?: number;
  private videoLoopRunning: boolean = false;
  // é¢„åŠ è½½çš„è§†é¢‘é…ç½®
  private videoConfig?: VideoConfig;
  // æ–­å¼€è¿æ¥å›è°ƒ
  private onDisconnectCallback?: (reason: string) => void;
  // é¦–å¸§å›è°ƒ - è§†é¢‘å¼€å§‹ä¼ è¾“æ—¶è§¦å‘
  private onFirstFrameCallback?: () => void;
  private firstFrameReceived: boolean = false;
  
  constructor(device: Device) {
    this.device = device;
  }
  
  // è·å–è§†é¢‘å°ºå¯¸ (ç”¨äºè§¦æ‘¸åæ ‡è®¡ç®—)
  getVideoSize(): VideoConfig | null {
    return this.videoConfig || null;
  }
  
  // è®¾ç½®æ–­å¼€è¿æ¥å›è°ƒ
  setOnDisconnect(callback: (reason: string) => void): void {
    this.onDisconnectCallback = callback;
  }
  
  // è§¦å‘æ–­å¼€å›è°ƒ
  private triggerDisconnect(reason: string): void {
    console.warn(`[Client] Disconnect triggered: ${reason}`);
    if (this.onDisconnectCallback && !this.isClosed) {
      this.onDisconnectCallback(reason);
    }
    this.close();
  }

  // è®¾ç½®é¦–å¸§å›è°ƒ - è§†é¢‘å¼€å§‹ä¼ è¾“æ—¶è§¦å‘
  setOnFirstFrame(callback: () => void): void {
    this.onFirstFrameCallback = callback;
  }
  
  // ä»ç¼“å­˜è·å–å·²è¿æ¥çš„å®¢æˆ·ç«¯
  static getClient(uuid: string): Client | null {
    return Client.allClients.get(uuid) || null;
  }
  
  static async startDevice(device: Device, context: common.UIAbilityContext, uiContext: UIContext, onStatusChange?: (status: string) => void): Promise<Client | null> {
    if (Client.allClients.has(device.uuid)) {
      return Client.allClients.get(device.uuid) || null;
    }
    
    const client = new Client(device);
    const success = await client.connect(context, uiContext, onStatusChange);
    
    if (success) {
      Client.allClients.set(device.uuid, client);
      return client;
    }
    
    // è¿æ¥å¤±è´¥ï¼Œç¡®ä¿æ¸…ç†èµ„æº
    console.info('[Client] startDevice failed, cleaning up...');
    await client.close();
    return null;
  }
  
  private async connect(context: common.UIAbilityContext, uiContext: UIContext, onStatusChange?: (status: string) => void): Promise<boolean> {
    try {
      // 1. å»ºç«‹æµè¿æ¥
      this.clientStream = new ClientStream(this.device);
      
      if (onStatusChange) onStatusChange('æ­£åœ¨å»ºç«‹è¿æ¥...');
      const connected = await this.clientStream.connect(context, uiContext);
      
      if (!connected) {
        console.error('ClientStream connection failed');
        // è¿æ¥å¤±è´¥ï¼Œå…³é—­æµ
        await this.clientStream.close();
        this.clientStream = undefined;
        return false;
      }
      
      if (onStatusChange) onStatusChange('æ­£åœ¨è·å–è§†é¢‘é…ç½®...');
      // 2. ç«‹å³å¼€å§‹è¯»å–è§†é¢‘é…ç½®(ä¸ç­‰å¾…surface),é˜²æ­¢æœåŠ¡å™¨è¶…æ—¶
      // 2. Video config is already loaded during handshake
      const videoConfig = this.clientStream.getVideoConfig();
      if (videoConfig) {
        console.info(`Video config loaded: ${videoConfig.width}x${videoConfig.height}`);
      } else {
        console.warn('Video config not available after connect');
      }
      
      // 3. å¯åŠ¨ä¿æ´»å®šæ—¶å™¨
      this.startKeepAlive();

      // 4. å¯åŠ¨ä¸»æ¶ˆæ¯å¾ªç¯ï¼ˆæ¥æ”¶å‰ªè´´æ¿å’Œè§†é¢‘å¤§å°äº‹ä»¶ï¼‰
      this.startMainLoop();

      // 5. æ ¹æ®è®¾ç½®æ‰§è¡Œè¿æ¥æ—¶æ“ä½œ (match Android Client.java lines 47-49)
      try {
        // å”¤é†’å±å¹• - Android uses "buttonWake" which sends createPowerEvent(1)
        if (this.device.wakeOnConnect) {
          console.info('ğŸ”† Waking up remote device screen (wakeOnConnect=true)...');
          this.handleAction(Action.BUTTON_WAKE); // createPowerEvent(1)
        }

        // è¿æ¥æ—¶ç†„å± - Android uses "buttonLightOff" with 2000ms delay
        if (this.device.lightOffOnConnect) {
          console.info('ğŸŒ‘ Turning off remote device screen (lightOffOnConnect=true)...');
          // Android: clientController.handleAction("buttonLightOff", null, 2000);
          await new Promise<void>((resolve: () => void) => setTimeout(resolve, 2000));
          this.handleAction(Action.BUTTON_LIGHT_OFF); // createLightEvent(0)
        }
      } catch (wakeErr) {
        console.error('ğŸ”† Failed to handle connect actions:', wakeErr);
      }

      console.info('Client connected successfully');
      return true;
    } catch (err) {
      console.error('Client connect failed:', err);
      // å‘ç”Ÿå¼‚å¸¸ï¼Œç¡®ä¿å…³é—­æµ
      if (this.clientStream) {
        await this.clientStream.close();
        this.clientStream = undefined;
      }
      return false;
    }
  }
  
  private handleClipboardText(data: ArrayBuffer): void {
    const decoder = util.TextDecoder.create('utf-8');
    const text = decoder.decodeToString(new Uint8Array(data));
    
    // è®¾ç½®å‰ªè´´æ¿
    if (this.device.clipboardAutosync) {
      try {
        const systemPasteboard = pasteboard.getSystemPasteboard();
        const pasteData = pasteboard.createData(pasteboard.MIMETYPE_TEXT_PLAIN, text);
        systemPasteboard.setData(pasteData);
      } catch (err) {
        console.error('Set clipboard failed:', err);
      }
    }
  }
  
  private handleVideoSizeEvent(data: ArrayBuffer): void {
    if (data.byteLength < 9) return;
    
    const view = new DataView(data);
    const width = view.getUint32(1, true);
    const height = view.getUint32(5, true);
    
    console.info(`Video size changed: ${width}x${height}`);
    // TODO: æ›´æ–°è§†é¢‘è§£ç å™¨é…ç½®
  }
  
  // é¢„åŠ è½½è§†é¢‘é…ç½® - å·²ç§»è‡³ ClientStream.performHandshake
  // private preloadVideoConfig(): void { ... }
  
  async initVideoDecoder(surfaceId: string): Promise<void> {
    if (!this.clientStream) {
      throw new Error('ClientStream not initialized');
    }
    
    try {
      console.info('Initializing video decoder...');
      console.debug('Waiting for video config (timeout: 5 seconds)...');
      
      // ç­‰å¾…è§†é¢‘é…ç½®é¢„åŠ è½½å®Œæˆ
      let retries = 0;
      const config = this.clientStream.getVideoConfig();
      if (!config) {
         throw new Error('Video configuration not available from handshake');
      }
      
      // ä¿å­˜é…ç½®ä¾› getVideoSize() ä½¿ç”¨
      this.videoConfig = config;

      // æ˜ å°„codecIdåˆ°string
      // 0=H264, 1=H265, 2=AV1
      let codecType = 'h264';
      if (config.codecId === 1) codecType = 'h265';
      if (config.codecId === 2) codecType = 'av1';

      const width = config.width;
      const height = config.height;
      
      // scrcpy 2.x+ åè®®ä¸­ï¼ŒSPS/PPS (csd) æ˜¯ä½œä¸ºæ™®é€šè§†é¢‘å¸§å‘é€çš„ï¼Œè€Œä¸æ˜¯åœ¨å¤´éƒ¨
      // æ‰€ä»¥è¿™é‡Œä¸éœ€è¦åˆå§‹åŒ–csd
      const csd0: ArrayBuffer = new ArrayBuffer(0);
      const csd1: ArrayBuffer | undefined = undefined;
      
      console.info(`Using handshake config: ${codecType.toUpperCase()}, ${width}x${height}`);
      
      // åˆå§‹åŒ–è§£ç å™¨
      this.videoDecoder = new VideoDecoder();
      await this.videoDecoder.init(codecType, surfaceId, width, height, csd0, csd1);
      
      console.info('Video decoder initialized, starting video loop...');
      
      // å¯åŠ¨è§†é¢‘è¯»å–å¾ªç¯
      this.startVideoLoop();
      
    } catch (err) {
      const error = err as Error;
      console.error('initVideoDecoder failed:', error.message);
      throw error;
    }
  }
  
  private startVideoLoop(): void {
    if (this.videoLoopRunning) return;

    this.videoLoopRunning = true;

    const readLoop = async () => {
      let disconnectReason = '';
      try {
        console.info('ğŸ“º Video loop started, waiting for frames...');
        let frameCount = 0;
        while (!this.isClosed && this.videoLoopRunning && this.clientStream) {
          try {
            // è¯»å–å¸§å¤§å°
            console.debug(`[Frame ${frameCount}] Reading frame size...`);
            const frameData = await this.clientStream.readFrameFromVideo();
            console.debug(`[Frame ${frameCount}] Got frame data: ${frameData.byteLength} bytes`);

            if (frameData.byteLength > 0 && this.videoDecoder) {
              // è§£ç å¸§ (PTSç”±è§£ç å™¨å†…éƒ¨å¤„ç†)
              console.debug(`[Frame ${frameCount}] Calling videoDecoder.decode()...`);
              await this.videoDecoder.decode(frameData, 0);
              console.debug(`[Frame ${frameCount}] videoDecoder.decode() completed`);
              
              // é¦–å¸§å›è°ƒ - é€šçŸ¥UIè§†é¢‘å·²å¼€å§‹ä¼ è¾“
              if (!this.firstFrameReceived && this.onFirstFrameCallback) {
                this.firstFrameReceived = true;
                console.info('ğŸ¬ First frame received, triggering callback');
                this.onFirstFrameCallback();
              }
              
              frameCount++;
            } else {
              console.warn(`[Frame ${frameCount}] Empty frame received: videoDecoder=${!!this.videoDecoder}`);
            }
          } catch (frameErr) {
            const errMsg = frameErr instanceof Error ? frameErr.message : String(frameErr);
            console.error('Video frame read error:', errMsg);
            if (frameErr instanceof Error && frameErr.stack) {
              console.error('Stack:', frameErr.stack);
            }
            disconnectReason = 'è¿æ¥å·²æ–­å¼€: ' + errMsg;
            break;
          }
        }
      } catch (err) {
        const errMsg = err instanceof Error ? err.message : String(err);
        console.error('Video loop error:', errMsg);
        disconnectReason = 'è§†é¢‘å¾ªç¯é”™è¯¯: ' + errMsg;
      } finally {
        this.videoLoopRunning = false;
        console.info('Video loop stopped');
        
        // å¦‚æœä¸æ˜¯æ­£å¸¸å…³é—­ï¼Œè§¦å‘æ–­å¼€å›è°ƒ
        if (disconnectReason && !this.isClosed) {
          this.triggerDisconnect(disconnectReason);
        }
      }
    };

    // å¯åŠ¨è¯»å–å¾ªç¯
    readLoop();
  }

  // handleAction - å¯¹åº” Java ClientController.handleAction
  // ç»Ÿä¸€æ“ä½œå¤„ç†å…¥å£ï¼Œä½¿ç”¨ action å­—ç¬¦ä¸²åˆ†å‘
  handleAction(action: string, data?: ArrayBuffer): void {
    if (!this.clientStream || this.isClosed) return;

    try {
      switch (action) {
        // ç•Œé¢åˆ‡æ¢ - HarmonyOS æš‚ä¸å®ç°
        case Action.CHANGE_TO_SMALL:
        case Action.CHANGE_TO_FULL:
        case Action.CHANGE_TO_MINI:
        case Action.CHANGE_TO_APP:
          // HarmonyOS ä¸æ”¯æŒå¤šçª—å£æ¨¡å¼ï¼Œæš‚ä¸å¤„ç†
          break;

        // æŒ‰é’®æ“ä½œ - ä½¿ç”¨ Scrcpy å®˜æ–¹åè®®
        case Action.BUTTON_BACK:
          // ä½¿ç”¨ BACK_OR_SCREEN_ON ç±»å‹ï¼ŒACTION_DOWN è§¦å‘è¿”å›
          this.writeToMain(ControlPacket.createBackOrScreenOn(0)); // ACTION_DOWN
          break;
        case Action.BUTTON_HOME:
          for (const pkt of ControlPacket.createHomeKey()) {
            this.writeToMain(pkt);
          }
          break;
        case Action.BUTTON_SWITCH:
          for (const pkt of ControlPacket.createAppSwitchKey()) {
            this.writeToMain(pkt);
          }
          break;
        case Action.BUTTON_ROTATE:
          this.writeToMain(ControlPacket.createRotateDevice());
          break;
        case Action.BUTTON_POWER:
          for (const pkt of ControlPacket.createPowerKey()) {
            this.writeToMain(pkt);
          }
          break;
        case Action.BUTTON_WAKE:
          this.writeToMain(ControlPacket.createScreenOn());
          break;
        case Action.BUTTON_LOCK:
          this.writeToMain(ControlPacket.createScreenOff());
          break;
        case Action.BUTTON_LIGHT:
          // åˆ‡æ¢å±å¹•çŠ¶æ€
          this.writeToMain(ControlPacket.createScreenOn());
          break;
        case Action.BUTTON_LIGHT_OFF:
          this.writeToMain(ControlPacket.createScreenOff());
          break;

        // ç³»ç»Ÿæ“ä½œ - Scrcpy æ²¡æœ‰ keepaliveï¼Œä½¿ç”¨ç©ºæ“ä½œæˆ–è·³è¿‡
        case Action.KEEP_ALIVE:
          // Scrcpy ä¸éœ€è¦ keepaliveï¼Œå¯ä»¥å‘é€ä¸€ä¸ªæ— å®³çš„æ¶ˆæ¯å¦‚ GET_CLIPBOARD
          // æˆ–ç›´æ¥è·³è¿‡
          break;
        case Action.CHECK_SIZE_AND_SITE:
          // HarmonyOS ä¸éœ€è¦æ£€æŸ¥æ‚¬æµ®çª—ä½ç½®
          break;
        case Action.CHECK_CLIP_BOARD:
          // å‰ªè´´æ¿æ£€æŸ¥åœ¨ mainLoop ä¸­å¤„ç†
          break;
        case Action.UPDATE_SITE:
          // æ‚¬æµ®çª—ä½ç½®æ›´æ–°ï¼ŒHarmonyOS ä¸éœ€è¦
          break;
        case Action.UPDATE_MAX_SIZE:
          // æœ€å¤§å°ºå¯¸æ›´æ–°ï¼ŒHarmonyOS æš‚ä¸éœ€è¦
          break;
        case Action.UPDATE_VIDEO_SIZE:
          // è§†é¢‘å°ºå¯¸æ›´æ–°ï¼Œåœ¨ handleVideoSizeEvent ä¸­å¤„ç†
          break;
        case Action.RUN_SHELL:
          // Shell å‘½ä»¤æ‰§è¡Œï¼Œæš‚ä¸å®ç°
          break;

        // ç›´æ¥å†™å…¥æ•°æ®åŒ…
        case Action.WRITE_BYTE_BUFFER:
          if (data) {
            this.writeToMain(data);
          }
          break;

        // è®¾ç½®å‰ªè´´æ¿
        case Action.SET_CLIP_BOARD:
          if (data && data.byteLength > 0) {
            this.writeToMain(data);
          }
          break;

        default:
          console.warn(`[Client] Unknown action: ${action}`);
          // å…¼å®¹ï¼šå¦‚æœæœ‰ dataï¼Œé»˜è®¤æ‰§è¡Œ writeByteBuffer
          if (data) {
            this.writeToMain(data);
          }
          break;
      }
    } catch (err) {
      console.error(`[Client] handleAction error for ${action}:`, err);
    }
  }

  // å†…éƒ¨æ–¹æ³•ï¼šå†™å…¥æ•°æ®æµ
  private async writeToMain(data: ArrayBuffer): Promise<void> {
    if (this.clientStream) {
      await this.clientStream.writeMain(data);
    }
  }

  // å‘é€è§¦æ‘¸äº‹ä»¶ - Scrcpy åè®®æ ¼å¼
  // x, y: å±å¹•åæ ‡ (åƒç´ å€¼)
  // screenWidth, screenHeight: å±å¹•å°ºå¯¸
  async sendTouchEvent(
    action: TouchAction, 
    pointerId: number, 
    x: number, 
    y: number, 
    screenWidth: number,
    screenHeight: number,
    pressure: number = 1.0
  ): Promise<void> {
    if (!this.clientStream) {
      console.warn('[Control] sendTouchEvent: clientStream is null');
      return;
    }
    
    console.debug(`[Control] sendTouchEvent: action=${action}, pointerId=${pointerId}, pos=(${x},${y}), screen=${screenWidth}x${screenHeight}`);
    
    const packet = ControlPacket.createInjectTouchEvent(
      action, 
      BigInt(pointerId), 
      Math.round(x), 
      Math.round(y), 
      screenWidth, 
      screenHeight,
      pressure
    );
    await this.clientStream.writeMain(packet);
  }

  
  // å‘é€æŒ‰é”®äº‹ä»¶ - å‘é€æŒ‰ä¸‹å’ŒæŠ¬èµ·
  async sendKeyEvent(keyCode: KeyCode, metaState: number = 0): Promise<void> {
    if (!this.clientStream) {
      console.warn('[Control] sendKeyEvent: clientStream is null');
      return;
    }
    
    console.debug(`[Control] sendKeyEvent: keyCode=${keyCode}, metaState=${metaState}`);
    
    const packets = ControlPacket.createKeyEventPair(keyCode, metaState);
    for (const packet of packets) {
      await this.clientStream.writeMain(packet);
    }
  }

  private startKeepAlive(): void {
    this.keepAliveTimer = setInterval(() => {
      if (!this.isClosed && this.clientStream) {
        this.handleAction(Action.KEEP_ALIVE);
      }
    }, 3000);
  }

  // å¯åŠ¨ä¸»æ¶ˆæ¯å¾ªç¯ - æ¥æ”¶æœåŠ¡å™¨å‘é€çš„äº‹ä»¶ï¼ˆå‰ªè´´æ¿ã€è§†é¢‘å¤§å°ç­‰ï¼‰
  private startMainLoop(): void {
    const readLoop = async (): Promise<void> => {
      while (!this.isClosed && this.clientStream) {
        try {
          // è¯»å–äº‹ä»¶ç±»å‹
          const eventType = await this.clientStream.readByteFromMain();

          if (this.isClosed) break;

          switch (eventType) {
            case 0: // DEVICE_MSG_TYPE_CLIPBOARD
              console.debug('[MainLoop] Received clipboard event');
              // clipboard message: type(1) + length(4) + text
              const clipLen = await this.clientStream.readIntFromMain();
              if (clipLen > 0 && clipLen <= 100000) { // Limit sanity check
                const clipTextData = await this.clientStream.readBytesFromMain(clipLen);
                this.handleClipboardText(clipTextData);
              }
              break;

            case 1: // DEVICE_MSG_TYPE_ACK_CLIPBOARD
              console.debug('[MainLoop] Received ack clipboard event');
              // ack clipboard: type(1) + sequence(8)
              await this.clientStream.readBytesFromMain(8); // Ignore sequence
              break;
              
            case 2: // DEVICE_MSG_TYPE_UHID_OUTPUT
              console.debug('[MainLoop] Received UHID output event');
               // uhid output: type(1) + id(2) + size(2) + data
              const id = (await this.clientStream.readBytesFromMain(2)); // read 2 bytes
              const sizeData = await this.clientStream.readBytesFromMain(2);
              const view = new DataView(sizeData);
              const size = view.getUint16(0, false);
              if (size > 0) {
                await this.clientStream.readBytesFromMain(size);
              }
              break;

            default:
              console.debug(`[MainLoop] Unknown event type: ${eventType}`);
              break;
          }
        } catch (err) {
          if (this.isClosed) {
            console.debug('[MainLoop] Client closed, exiting loop');
            break;
          }

          const errorMsg = err instanceof Error ? err.message : String(err);
          if (!errorMsg.includes('timeout') && !errorMsg.includes('closed')) {
            console.error('[MainLoop] Read error:', err);
            // çŸ­æš‚å»¶è¿Ÿåé‡è¯•
            await new Promise<void>((resolve: () => void) => setTimeout(resolve, 100));
          }
        }
      }
    };

    // å¯åŠ¨å¼‚æ­¥è¯»å–å¾ªç¯
    readLoop().catch((err: Error) => {
      console.error('[MainLoop] Loop error:', err);
    });
  }
  
  async close(): Promise<void> {
    if (this.isClosed) return;
    
    this.isClosed = true;
    
    // åœæ­¢è§†é¢‘å¾ªç¯
    this.videoLoopRunning = false;
    
    // åœæ­¢ä¿æ´»
    if (this.keepAliveTimer) {
      clearInterval(this.keepAliveTimer);
      this.keepAliveTimer = undefined;
    }
    
    // é‡Šæ”¾èµ„æº
    if (this.videoDecoder) {
      await this.videoDecoder.release();
      this.videoDecoder = undefined;
    }
    
    if (this.clientStream) {
      await this.clientStream.close();
      this.clientStream = undefined;
    }
    
    // ä»ç®¡ç†å™¨ç§»é™¤
    Client.allClients.delete(this.device.uuid);
    
    console.info('Client closed');
  }
  
  static async closeAll(): Promise<void> {
    for (const client of Client.allClients.values()) {
      await client.close();
    }
    Client.allClients.clear();
  }
  
  getDevice(): Device {
    return this.device;
  }
  
  isClientClosed(): boolean {
    return this.isClosed;
  }
}
