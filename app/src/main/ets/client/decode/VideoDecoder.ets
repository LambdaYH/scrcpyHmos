import { BusinessError } from '@ohos.base';
import scrcpy_native from 'libscrcpy_native.so';

// è§†é¢‘è§£ç å™¨ - ä½¿ç”¨Native C++ VideoDecoder
export class VideoDecoder {
  // é™æ€å®ä¾‹è¿½è¸ª - ç¡®ä¿åªæœ‰ä¸€ä¸ªè§£ç å™¨å®ä¾‹
  private static currentInstance: VideoDecoder | null = null;

  private decoderId: number = 0;
  private surfaceId: string = '';
  private isH265: boolean = false;
  private width: number = 0;
  private height: number = 0;
  private isStarted: boolean = false;
  private frameCount: number = 0;
  
  async init(useH265: boolean, surfaceId: string, width: number, height: number, csd0: ArrayBuffer, csd1?: ArrayBuffer): Promise<void> {
    this.isH265 = useH265;
    this.surfaceId = surfaceId;
    this.width = width;
    this.height = height;
    
    try {
      // é‡Šæ”¾ä¹‹å‰çš„è§£ç å™¨å®ä¾‹ï¼ˆé˜²æ­¢èµ„æºæ³„æ¼ï¼‰
      if (VideoDecoder.currentInstance && VideoDecoder.currentInstance !== this) {
        console.info('[VideoDecoder] Releasing previous decoder instance...');
        await VideoDecoder.currentInstance.release();
      }
      VideoDecoder.currentInstance = this;

      console.info(`[VideoDecoder] Initializing Native decoder...`);
      console.info(`[VideoDecoder] Codec: ${useH265 ? 'H.265/HEVC' : 'H.264/AVC'}`);
      console.info(`[VideoDecoder] Resolution: ${width}x${height}`);
      console.info(`[VideoDecoder] SurfaceId: ${surfaceId}`);
      console.info(`[VideoDecoder] CSD-0 (SPS/VPS) size: ${csd0.byteLength} bytes`);
      
      if (csd1) {
        console.info(`[VideoDecoder] CSD-1 (PPS) size: ${csd1.byteLength} bytes`);
      }
      
      // åˆ›å»ºNativeè§£ç å™¨
      this.decoderId = scrcpy_native.createDecoder();
      console.info(`[VideoDecoder] Native decoder created, ID: ${this.decoderId}`);
      
      // åˆå§‹åŒ–è§£ç å™¨
      const ret: number = scrcpy_native.initDecoder(this.decoderId, useH265, surfaceId, width, height);
      if (ret !== 0) {
        const error = new Error(`Native decoder init failed: ${ret}`);
        throw error;
      }
      console.info(`[VideoDecoder] Native decoder initialized`);
      
      // å¯åŠ¨è§£ç å™¨
      const startRet: number = scrcpy_native.startDecoder(this.decoderId);
      if (startRet !== 0) {
        const error = new Error(`Native decoder start failed: ${startRet}`);
        throw error;
      }
      
      this.isStarted = true;
      console.info(`[VideoDecoder] âœ… Native decoder started successfully!`);
      
      // æ¨é€CSDæ•°æ®
      if (csd0) {
        await this.decode(csd0, 0);
      }
      if (csd1) {
        await this.decode(csd1, 0);
      }
      
    } catch (err) {
      const error = err as Error;
      console.error(`[VideoDecoder] Init failed: ${error.message}`);
      const newError = new Error(`VideoDecoder init failed: ${error.message}`);
      throw newError;
    }
  }
  
  async decode(data: ArrayBuffer, pts: number): Promise<void> {
    // console.info(`[VideoDecoder] decode() called: ${data.byteLength} bytes, isStarted=${this.isStarted}, decoderId=${this.decoderId}`);

    if (!this.isStarted || this.decoderId === 0) {
      console.warn('[VideoDecoder] Not ready, frame dropped');
      return;
    }

    try {
      // æ¨é€æ•°æ®åˆ°Nativeè§£ç å™¨ï¼Œå¸¦é‡è¯•æœºåˆ¶
      const maxRetries = 10;
      let retryCount = 0;
      let result: number = -2;
      
      while (retryCount < maxRetries) {
        result = scrcpy_native.pushData(this.decoderId, data, pts);
        
        if (result === 0) {
          // æˆåŠŸ
          break;
        } else if (result === -2) {
          // æ²¡æœ‰å¯ç”¨è¾“å…¥ç¼“å†²åŒºï¼Œç­‰å¾…åé‡è¯•
          retryCount++;
          if (retryCount < maxRetries) {
            await new Promise<void>((resolve: () => void) => setTimeout(resolve, 10));
          }
        } else {
          // å…¶ä»–é”™è¯¯ï¼Œä¸é‡è¯•
          console.error(`[VideoDecoder] pushData failed with error: ${result}`);
          break;
        }
      }
      
      if (result === 0) {
        this.frameCount++;
        // æ¯30å¸§è¾“å‡ºä¸€æ¬¡æ—¥å¿—
        // if (this.frameCount % 30 === 0) {
        //   console.info(`[VideoDecoder] ğŸ¬ Decoded ${this.frameCount} frames | Latest: ${data.byteLength} bytes, PTS=${pts}`);
        // }
      } else if (result === -2) {
        console.warn(`[VideoDecoder] Frame dropped after ${maxRetries} retries (no available input buffer)`);
      }
    } catch (err) {
      console.error('[VideoDecoder] Decode error:', err);
    }
  }
  
  async flush(): Promise<void> {
    if (this.isStarted) {
      console.info('[VideoDecoder] Flushing decoder...');
      this.frameCount = 0;
    }
  }
  
  async release(): Promise<void> {
    if (this.decoderId !== 0) {
      try {
        this.isStarted = false;
        scrcpy_native.releaseDecoder(this.decoderId);
        this.decoderId = 0;
        console.info(`[VideoDecoder] Released | Total frames decoded: ${this.frameCount}`);
      } catch (err) {
        console.error('[VideoDecoder] Release failed:', err);
      }
    }
  }
}
