{
  "permissions": {
    "allow": [
      "Bash(mkdir:*)",
      "Bash(hvigorw assembleHap:*)",
      "Bash(./hvigorw.bat assembleHap)",
      "Bash(hvigorw.bat assembleHap:*)",
      "Bash(ls:*)",
      "Bash(cmd //c \"hvigorw.bat assembleHap --no-build-cache\")",
      "Bash(tree:*)",
      "Bash(dir:*)",
      "WebFetch(domain:developer.huawei.com)",
      "Bash(powershell:*)",
      "Bash(cmd:*)",
      "WebSearch",
      "Bash(python:*)",
      "Bash(\"D:\\\\dev\\\\scrcpyHmos\\\\app\\\\src\\\\main\\\\ets\\\\workers\\\\StreamWorker.ets\" << 'ENDOFFILE'\n// StreamWorker.ets - Worker 线程，负责 ADB 连接、视频流、音频流、控制流处理\nimport { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';\nimport { Device } from '../entity/Device';\nimport { ClientStream, VideoConfig } from '../client/tools/ClientStream';\nimport { VideoDecoder } from '../client/decode/VideoDecoder';\nimport { AudioDecoder } from '../client/decode/AudioDecoder';\nimport { ControlPacket, Action, TouchAction, KeyCode } from '../client/tools/ControlPacket';\nimport { LoggerClient } from '../helper/Logger';\nimport { util } from '@kit.ArkTS';\nimport { common } from '@kit.AbilityKit';\n\nconst workerPort: ThreadWorkerGlobalScope = worker.workerPort;\n\n// Worker 消息类型定义\nexport enum WorkerMessageType {\n  // 主线程 -> Worker\n  INIT = 'init',\n  INIT_VIDEO_DECODER = 'init_video_decoder',\n  INIT_AUDIO_DECODER = 'init_audio_decoder',\n  SEND_TOUCH = 'send_touch',\n  SEND_KEY = 'send_key',\n  SEND_CLIPBOARD = 'send_clipboard',\n  HANDLE_ACTION = 'handle_action',\n  CLOSE = 'close',\n\n  // Worker -> 主线程\n  STATUS_UPDATE = 'status_update',\n  CONNECTED = 'connected',\n  DISCONNECTED = 'disconnected',\n  ERROR = 'error',\n  VIDEO_CONFIG = 'video_config',\n  FIRST_FRAME = 'first_frame',\n  CLIPBOARD_RECEIVED = 'clipboard_received',\n  AUTH_REQUIRED = 'auth_required',\n}\n\n// 消息接口\nexport interface WorkerMessage {\n  type: WorkerMessageType;\n  data?: ESObject;\n}\n\n// 触摸事件数据\nexport interface TouchEventData {\n  action: TouchAction;\n  pointerId: number;\n  x: number;\n  y: number;\n  screenWidth: number;\n  screenHeight: number;\n  pressure?: number;\n}\n\n// 按键事件数据\nexport interface KeyEventData {\n  keyCode: KeyCode;\n  metaState?: number;\n}\n\n// 初始化数据\nexport interface InitData {\n  device: Device;\n  context: common.UIAbilityContext;\n  uiContext: UIContext;\n}\n\n// Worker 状态\nclass WorkerState {\n  private device?: Device;\n  private clientStream?: ClientStream;\n  private videoDecoder?: VideoDecoder;\n  private audioDecoder?: AudioDecoder;\n  private isClosed: boolean = false;\n  private keepAliveTimer?: number = undefined;\n  private videoLoopRunning: boolean = false;\n  private audioLoopRunning: boolean = false;\n  private videoConfig?: VideoConfig;\n  private audioCodec?: string;\n  private firstFrameReceived: boolean = false;\n  private uiContext?: UIContext;\n\n  // 触控事件优化\n  private isWritingMove: boolean = false;\n  private pendingMovePacket: ArrayBuffer | null = null;\n\n  constructor\\(\\) {\n    LoggerClient.info\\('[StreamWorker] Worker state initialized'\\);\n  }\n\n  // 发送消息到主线程\n  private postMessage\\(message: WorkerMessage\\): void {\n    workerPort.postMessage\\(message\\);\n  }\n\n  // 初始化并连接\n  async init\\(device: Device, context: common.UIAbilityContext, uiContext: UIContext\\): Promise<void> {\n    try {\n      this.device = device;\n      this.uiContext = uiContext;\n      this.isClosed = false;\n\n      LoggerClient.info\\('[StreamWorker] Starting connection...'\\);\n      this.postMessage\\({ type: WorkerMessageType.STATUS_UPDATE, data: { status: 'Connecting...' } }\\);\n\n      // 建立流连接\n      this.clientStream = new ClientStream\\(this.device\\);\n\n      const connected = await this.clientStream.connect\\(context, uiContext, \\(\\) => {\n        // 授权回调\n        this.postMessage\\({ type: WorkerMessageType.AUTH_REQUIRED }\\);\n      }\\);\n\n      if \\(!connected\\) {\n        LoggerClient.error\\('[StreamWorker] Connection failed'\\);\n        if \\(this.clientStream\\) {\n          await this.clientStream.close\\(\\);\n          this.clientStream = undefined;\n        }\n        this.postMessage\\({\n          type: WorkerMessageType.ERROR,\n          data: { message: 'Connection failed' }\n        }\\);\n        return;\n      }\n\n      this.postMessage\\({ type: WorkerMessageType.STATUS_UPDATE, data: { status: 'Getting video config...' } }\\);\n\n      // 获取视频配置\n      const videoConfig = this.clientStream.getVideoConfig\\(\\);\n      if \\(videoConfig\\) {\n        this.videoConfig = videoConfig;\n        LoggerClient.debug\\('[StreamWorker] Video config: ' + videoConfig.width + 'x' + videoConfig.height\\);\n        this.postMessage\\({\n          type: WorkerMessageType.VIDEO_CONFIG,\n          data: { config: videoConfig }\n        }\\);\n      } else {\n        LoggerClient.warn\\('[StreamWorker] Video config not available'\\);\n      }\n\n      // 启动保活定时器\n      this.startKeepAlive\\(\\);\n\n      // 启动主消息循环\n      this.startMainLoop\\(\\);\n\n      // 执行连接时操作\n      try {\n        if \\(this.device.wakeOnConnect\\) {\n          LoggerClient.debug\\('[StreamWorker] Waking up screen...'\\);\n          this.handleAction\\(Action.BUTTON_WAKE\\);\n        }\n\n        if \\(this.device.lightOffOnConnect\\) {\n          LoggerClient.info\\('[StreamWorker] Turning off screen...'\\);\n          await new Promise<void>\\(\\(resolve\\) => setTimeout\\(resolve, 2000\\)\\);\n          this.handleAction\\(Action.BUTTON_LIGHT_OFF\\);\n        }\n      } catch \\(err\\) {\n        LoggerClient.error\\('[StreamWorker] Failed to handle connect actions:', err\\);\n      }\n\n      LoggerClient.info\\('[StreamWorker] Connection established'\\);\n      this.postMessage\\({ type: WorkerMessageType.CONNECTED }\\);\n\n    } catch \\(err\\) {\n      const errMsg = err instanceof Error ? err.message : String\\(err\\);\n      LoggerClient.error\\('[StreamWorker] Init failed:', errMsg\\);\n      this.postMessage\\({\n        type: WorkerMessageType.ERROR,\n        data: { message: errMsg }\n      }\\);\n\n      if \\(this.clientStream\\) {\n        await this.clientStream.close\\(\\);\n        this.clientStream = undefined;\n      }\n    }\n  }\n\n  // 初始化视频解码器\n  async initVideoDecoder\\(surfaceId: string\\): Promise<void> {\n    if \\(!this.clientStream\\) {\n      throw new Error\\('ClientStream not initialized'\\);\n    }\n\n    try {\n      LoggerClient.debug\\('[StreamWorker] Initializing video decoder...'\\);\n\n      const config = this.clientStream.getVideoConfig\\(\\);\n      if \\(!config\\) {\n        throw new Error\\('Video configuration not available'\\);\n      }\n\n      // 映射 codecId 到字符串\n      let codecType = 'h264';\n      if \\(config.codecId === 1 || config.codecId === 1748121141\\) codecType = 'h265';\n      if \\(config.codecId === 2 || config.codecId === 1635135537\\) codecType = 'av1';\n\n      LoggerClient.info\\('[StreamWorker] Codec: ' + codecType + ', Size: ' + config.width + 'x' + config.height\\);\n\n      // 初始化解码器\n      this.videoDecoder = new VideoDecoder\\(\\);\n      await this.videoDecoder.init\\(codecType, surfaceId, config.width, config.height\\);\n\n      LoggerClient.debug\\('[StreamWorker] Video decoder initialized, starting loop...'\\);\n\n      // 启动视频循环\n      this.startVideoLoop\\(\\);\n\n    } catch \\(err\\) {\n      const error = err as Error;\n      LoggerClient.error\\('[StreamWorker] initVideoDecoder failed:', error.message\\);\n      throw error;\n    }\n  }\n\n  // 初始化音频解码器\n  async initAudioDecoder\\(codecType: string = 'opus', sampleRate: number = 48000, channelCount: number = 2\\): Promise<void> {\n    if \\(!this.clientStream\\) {\n      throw new Error\\('ClientStream not initialized'\\);\n    }\n\n    if \\(!this.device?.isAudio\\) {\n      LoggerClient.info\\('[StreamWorker] Audio disabled, skipping'\\);\n      return;\n    }\n\n    try {\n      // 读取音频编码头\n      const audioConfig = this.clientStream.getAudioConfig\\(\\);\n      let actualCodec = codecType;\n\n      if \\(audioConfig\\) {\n        if \\(audioConfig.codecName === 'disabled'\\) {\n          LoggerClient.info\\('[StreamWorker] Audio disabled by server'\\);\n          if \\(this.device\\) {\n            this.device.isAudio = false;\n          }\n          return;\n        }\n        actualCodec = audioConfig.codecName;\n        this.audioCodec = actualCodec;\n      } else {\n        LoggerClient.debug\\('[StreamWorker] Reading audio codec header...'\\);\n        const codecRead = await this.clientStream.readAudioCodecHeader\\(\\);\n        const newConfig = this.clientStream.getAudioConfig\\(\\);\n\n        if \\(newConfig\\) {\n          if \\(newConfig.codecName === 'disabled'\\) {\n            LoggerClient.info\\('[StreamWorker] Audio disabled by server'\\);\n            if \\(this.device\\) {\n              this.device.isAudio = false;\n            }\n            return;\n          }\n          actualCodec = newConfig.codecName;\n          this.audioCodec = actualCodec;\n        } else if \\(!codecRead\\) {\n          LoggerClient.warn\\('[StreamWorker] Failed to read audio codec, using device config'\\);\n          actualCodec = this.device?.audioCodec || 'opus';\n          this.audioCodec = actualCodec;\n        }\n      }\n\n      LoggerClient.debug\\('[StreamWorker] Initializing audio decoder: ' + actualCodec\\);\n\n      this.audioDecoder = new AudioDecoder\\(\\);\n      await this.audioDecoder.init\\(actualCodec, sampleRate, channelCount\\);\n\n      LoggerClient.info\\('[StreamWorker] Audio decoder initialized'\\);\n\n      await this.audioDecoder.createStreamProcessor\\(actualCodec, sampleRate, channelCount\\);\n      await this.audioDecoder.startStreamProcessor\\(\\);\n\n      // 启动音频循环\n      this.startAudioLoop\\(\\);\n\n    } catch \\(err\\) {\n      const error = err as Error;\n      LoggerClient.error\\('[StreamWorker] initAudioDecoder failed:', error.message\\);\n      throw error;\n    }\n  }\n\n  // 视频循环\n  private startVideoLoop\\(\\): void {\n    if \\(this.videoLoopRunning\\) return;\n    if \\(!this.videoDecoder || !this.clientStream\\) {\n      LoggerClient.error\\('[StreamWorker] Decoder or stream not initialized'\\);\n      return;\n    }\n\n    this.videoLoopRunning = true;\n\n    const videoThread = async \\(\\) => {\n      let frameCount = 0;\n\n      try {\n        while \\(!this.isClosed && this.videoLoopRunning && this.clientStream\\) {\n          try {\n            const frame = await this.clientStream.readFrameFromVideo\\(\\);\n            const decoder = this.videoDecoder;\n\n            if \\(frame.data.byteLength > 0 && decoder\\) {\n              const pushResult = decoder.pushFrame\\(frame.data, frame.pts, frame.flags\\);\n\n              if \\(pushResult === 0\\) {\n                frameCount++;\n                if \\(frameCount === 1 && !this.firstFrameReceived\\) {\n                  this.firstFrameReceived = true;\n                  LoggerClient.info\\('[StreamWorker] First video frame received'\\);\n                  this.postMessage\\({ type: WorkerMessageType.FIRST_FRAME }\\);\n                }\n              } else if \\(pushResult === -2\\) {\n                // Buffer 满，等待重试\n                let waitCount = 0;\n                const maxWait = 50;\n                while \\(waitCount < maxWait && !this.isClosed && decoder\\) {\n                  await new Promise<void>\\(\\(resolve\\) => setTimeout\\(resolve, 1\\)\\);\n                  const retryResult = decoder.pushFrame\\(frame.data, frame.pts, frame.flags\\);\n                  if \\(retryResult === 0\\) {\n                    frameCount++;\n                    break;\n                  }\n                  waitCount++;\n                }\n              }\n            }\n          } catch \\(err\\) {\n            const errMsg = err instanceof Error ? err.message : String\\(err\\);\n            if \\(this.isClosed || errMsg.includes\\('closed'\\)\\) {\n              LoggerClient.debug\\('[StreamWorker] Video loop terminated'\\);\n              break;\n            }\n            LoggerClient.error\\('[StreamWorker] Video frame error:', errMsg\\);\n            break;\n          }\n        }\n      } catch \\(err\\) {\n        LoggerClient.error\\('[StreamWorker] Video loop error:', err\\);\n      } finally {\n        this.videoLoopRunning = false;\n        LoggerClient.info\\('[StreamWorker] Video loop stopped'\\);\n      }\n    };\n\n    videoThread\\(\\);\n  }\n\n  // 音频循环\n  private startAudioLoop\\(\\): void {\n    if \\(this.audioLoopRunning\\) return;\n    if \\(!this.device?.isAudio || !this.clientStream\\) {\n      LoggerClient.debug\\('[StreamWorker] Audio disabled or not initialized'\\);\n      return;\n    }\n\n    this.audioLoopRunning = true;\n\n    const pushLoop = async \\(\\) => {\n      try {\n        LoggerClient.debug\\('[StreamWorker] Audio push loop started'\\);\n        while \\(!this.isClosed && this.audioLoopRunning && this.clientStream\\) {\n          try {\n            const frame = await this.clientStream.readFrameFromAudio\\(\\);\n            if \\(frame.data.byteLength > 0 && this.audioDecoder\\) {\n              const pushResult = this.audioDecoder.pushFrame\\(frame.data, frame.pts\\);\n              if \\(pushResult < 0\\) {\n                await new Promise<void>\\(\\(resolve\\) => setTimeout\\(resolve, 1\\)\\);\n              }\n            }\n          } catch \\(frameErr\\) {\n            const errMsg = frameErr instanceof Error ? frameErr.message : String\\(frameErr\\);\n            if \\(this.isClosed || errMsg.includes\\('closed'\\)\\) {\n              LoggerClient.debug\\('[StreamWorker] Audio loop terminated'\\);\n              break;\n            }\n            LoggerClient.error\\('[StreamWorker] Audio frame error:', errMsg\\);\n          }\n        }\n      } catch \\(err\\) {\n        LoggerClient.error\\('[StreamWorker] Audio loop error:', err\\);\n      } finally {\n        this.audioLoopRunning = false;\n        LoggerClient.debug\\('[StreamWorker] Audio loop stopped'\\);\n      }\n    };\n\n    pushLoop\\(\\);\n  }\n\n  // 处理剪贴板文本\n  private async handleClipboardText\\(data: ArrayBuffer\\): Promise<void> {\n    const decoder = util.TextDecoder.create\\('utf-8'\\);\n    const text = decoder.decodeToString\\(new Uint8Array\\(data\\)\\);\n\n    // 发送到主线程处理剪贴板同步\n    this.postMessage\\({\n      type: WorkerMessageType.CLIPBOARD_RECEIVED,\n      data: { text, autoSync: this.device?.clipboardAutosync }\n    }\\);\n  }\n\n  // 启动主消息循环\n  private startMainLoop\\(\\): void {\n    const readLoop = async \\(\\): Promise<void> => {\n      while \\(!this.isClosed && this.clientStream\\) {\n        try {\n          const eventType = await this.clientStream.readByteFromMain\\(\\);\n\n          if \\(this.isClosed\\) break;\n\n          switch \\(eventType\\) {\n            case 0: // DEVICE_MSG_TYPE_CLIPBOARD\n              LoggerClient.debug\\('[StreamWorker] Received clipboard event'\\);\n              const clipLen = await this.clientStream.readIntFromMain\\(\\);\n              if \\(clipLen > 0 && clipLen <= 100000\\) {\n                const clipTextData = await this.clientStream.readBytesFromMain\\(clipLen\\);\n                await this.handleClipboardText\\(clipTextData\\);\n              }\n              break;\n\n            case 1: // DEVICE_MSG_TYPE_ACK_CLIPBOARD\n              LoggerClient.debug\\('[StreamWorker] Received ack clipboard event'\\);\n              await this.clientStream.readBytesFromMain\\(8\\);\n              break;\n\n            case 2: // DEVICE_MSG_TYPE_UHID_OUTPUT\n              LoggerClient.debug\\('[StreamWorker] Received UHID output event'\\);\n              await this.clientStream.readBytesFromMain\\(2\\);\n              const sizeData = await this.clientStream.readBytesFromMain\\(2\\);\n              const view = new DataView\\(sizeData\\);\n              const size = view.getUint16\\(0, false\\);\n              if \\(size > 0\\) {\n                await this.clientStream.readBytesFromMain\\(size\\);\n              }\n              break;\n\n            default:\n              LoggerClient.debug\\('[StreamWorker] Unknown event type: ' + eventType\\);\n              break;\n          }\n        } catch \\(err\\) {\n          if \\(this.isClosed\\) {\n            LoggerClient.debug\\('[StreamWorker] Main loop exiting \\(closed\\)'\\);\n            break;\n          }\n\n          const errorMsg = err instanceof Error ? err.message : String\\(err\\);\n          if \\(!errorMsg.includes\\('timeout'\\) && !errorMsg.includes\\('closed'\\)\\) {\n            LoggerClient.error\\('[StreamWorker] Main loop error:', err\\);\n            await new Promise<void>\\(\\(resolve\\) => setTimeout\\(resolve, 100\\)\\);\n          }\n        }\n      }\n    };\n\n    readLoop\\(\\).catch\\(\\(err: Error\\) => {\n      LoggerClient.error\\('[StreamWorker] Main loop fatal error:', err\\);\n    }\\);\n  }\n\n  // 启动保活定时器\n  private startKeepAlive\\(\\): void {\n    this.keepAliveTimer = setInterval\\(\\(\\) => {\n      if \\(!this.isClosed && this.clientStream\\) {\n        this.handleAction\\(Action.KEEP_ALIVE\\);\n      }\n    }, 3000\\) as number;\n  }\n\n  // 处理动作\n  handleAction\\(action: string, data?: ArrayBuffer\\): void {\n    if \\(!this.clientStream || this.isClosed\\) return;\n\n    try {\n      switch \\(action\\) {\n        case Action.BUTTON_BACK:\n          this.writeToMain\\(ControlPacket.createBackOrScreenOn\\(0\\)\\);\n          break;\n        case Action.BUTTON_HOME:\n          for \\(const pkt of ControlPacket.createHomeKey\\(\\)\\) {\n            this.writeToMain\\(pkt\\);\n          }\n          break;\n        case Action.BUTTON_SWITCH:\n          for \\(const pkt of ControlPacket.createAppSwitchKey\\(\\)\\) {\n            this.writeToMain\\(pkt\\);\n          }\n          break;\n        case Action.BUTTON_ROTATE:\n          this.writeToMain\\(ControlPacket.createRotateDevice\\(\\)\\);\n          break;\n        case Action.BUTTON_POWER:\n          for \\(const pkt of ControlPacket.createPowerKey\\(\\)\\) {\n            this.writeToMain\\(pkt\\);\n          }\n          break;\n        case Action.BUTTON_WAKE:\n          this.writeToMain\\(ControlPacket.createScreenOn\\(\\)\\);\n          break;\n        case Action.BUTTON_LOCK:\n          this.writeToMain\\(ControlPacket.createScreenOff\\(\\)\\);\n          break;\n        case Action.BUTTON_LIGHT:\n          this.writeToMain\\(ControlPacket.createScreenOn\\(\\)\\);\n          break;\n        case Action.BUTTON_LIGHT_OFF:\n          this.writeToMain\\(ControlPacket.createScreenOff\\(\\)\\);\n          break;\n        case Action.KEEP_ALIVE:\n          // Scrcpy 不需要特殊的 keepalive\n          break;\n        case Action.WRITE_BYTE_BUFFER:\n          if \\(data\\) {\n            this.writeToMain\\(data\\);\n          }\n          break;\n        case Action.SET_CLIP_BOARD:\n          if \\(data && data.byteLength > 0\\) {\n            this.writeToMain\\(data\\);\n          }\n          break;\n        default:\n          LoggerClient.warn\\('[StreamWorker] Unknown action: ' + action\\);\n          if \\(data\\) {\n            this.writeToMain\\(data\\);\n          }\n          break;\n      }\n    } catch \\(err\\) {\n      LoggerClient.error\\('[StreamWorker] handleAction error for ' + action + ':', err\\);\n    }\n  }\n\n  // 写入数据到主流\n  private async writeToMain\\(data: ArrayBuffer\\): Promise<void> {\n    if \\(this.clientStream\\) {\n      await this.clientStream.writeMain\\(data\\);\n    }\n  }\n\n  // 发送触摸事件\n  async sendTouchEvent\\(data: TouchEventData\\): Promise<void> {\n    if \\(!this.clientStream\\) {\n      LoggerClient.warn\\('[StreamWorker] sendTouchEvent: clientStream is null'\\);\n      return;\n    }\n\n    const packet = ControlPacket.createInjectTouchEvent\\(\n      data.action,\n      BigInt\\(data.pointerId\\),\n      Math.round\\(data.x\\),\n      Math.round\\(data.y\\),\n      data.screenWidth,\n      data.screenHeight,\n      data.pressure || 1.0\n    \\);\n\n    // 优化 MOVE 事件\n    if \\(data.action === TouchAction.ACTION_MOVE\\) {\n      if \\(this.isWritingMove\\) {\n        this.pendingMovePacket = packet;\n        return;\n      }\n      this.isWritingMove = true;\n    }\n\n    try {\n      await this.clientStream.writeMain\\(packet\\);\n    } finally {\n      if \\(data.action === TouchAction.ACTION_MOVE\\) {\n        this.isWritingMove = false;\n        if \\(this.pendingMovePacket\\) {\n          const nextPacket = this.pendingMovePacket;\n          this.pendingMovePacket = null;\n          this.sendRawMovePacket\\(nextPacket\\);\n        }\n      }\n    }\n  }\n\n  // 递归发送移动包\n  private async sendRawMovePacket\\(packet: ArrayBuffer\\): Promise<void> {\n    if \\(this.isWritingMove\\) {\n      this.pendingMovePacket = packet;\n      return;\n    }\n\n    this.isWritingMove = true;\n    try {\n      if \\(this.clientStream\\) {\n        await this.clientStream.writeMain\\(packet\\);\n      }\n    } finally {\n      this.isWritingMove = false;\n      if \\(this.pendingMovePacket\\) {\n        const nextPacket = this.pendingMovePacket;\n        this.pendingMovePacket = null;\n        this.sendRawMovePacket\\(nextPacket\\);\n      }\n    }\n  }\n\n  // 发送按键事件\n  async sendKeyEvent\\(data: KeyEventData\\): Promise<void> {\n    if \\(!this.clientStream\\) {\n      LoggerClient.warn\\('[StreamWorker] sendKeyEvent: clientStream is null'\\);\n      return;\n    }\n\n    const packets = ControlPacket.createKeyEventPair\\(data.keyCode, data.metaState || 0\\);\n    for \\(const packet of packets\\) {\n      await this.clientStream.writeMain\\(packet\\);\n    }\n  }\n\n  // 发送剪贴板\n  async sendClipboard\\(text: string, paste: boolean = true\\): Promise<void> {\n    if \\(!this.clientStream || this.isClosed\\) return;\n\n    const packet = ControlPacket.createSetClipboard\\(text, 0n, paste\\);\n    await this.writeToMain\\(packet\\);\n    const displayText = text.length > 50 ? text.substring\\(0, 50\\) + '...' : text;\n    LoggerClient.info\\('[StreamWorker] Sent clipboard: ' + displayText\\);\n  }\n\n  // 关闭连接\n  async close\\(\\): Promise<void> {\n    if \\(this.isClosed\\) return;\n\n    this.isClosed = true;\n\n    // 停止循环\n    this.videoLoopRunning = false;\n    this.audioLoopRunning = false;\n\n    // 停止保活\n    if \\(this.keepAliveTimer\\) {\n      clearInterval\\(this.keepAliveTimer\\);\n      this.keepAliveTimer = undefined;\n    }\n\n    // 释放资源\n    if \\(this.videoDecoder\\) {\n      await this.videoDecoder.release\\(\\);\n      this.videoDecoder = undefined;\n    }\n\n    if \\(this.audioDecoder\\) {\n      await this.audioDecoder.release\\(\\);\n      this.audioDecoder = undefined;\n    }\n\n    if \\(this.clientStream\\) {\n      await this.clientStream.close\\(\\);\n      this.clientStream = undefined;\n    }\n\n    LoggerClient.info\\('[StreamWorker] Worker closed'\\);\n    this.postMessage\\({ type: WorkerMessageType.DISCONNECTED }\\);\n  }\n\n  // 获取视频尺寸\n  getVideoSize\\(\\): VideoConfig | null {\n    return this.videoConfig || null;\n  }\n}\n\n// Worker 全局状态\nconst workerState = new WorkerState\\(\\);\n\n/**\n * Defines the event handler to be called when the worker thread receives a message sent by the host thread.\n * The event handler is executed in the worker thread.\n */\nworkerPort.onmessage = \\(event: MessageEvents\\) => {\n  const message = event.data as WorkerMessage;\n\n  try {\n    switch \\(message.type\\) {\n      case WorkerMessageType.INIT:\n        const initData = message.data as InitData;\n        workerState.init\\(initData.device, initData.context, initData.uiContext\\);\n        break;\n\n      case WorkerMessageType.INIT_VIDEO_DECODER:\n        const videoData = message.data as { surfaceId: string };\n        workerState.initVideoDecoder\\(videoData.surfaceId\\);\n        break;\n\n      case WorkerMessageType.INIT_AUDIO_DECODER:\n        const audioData = message.data as { codecType?: string; sampleRate?: number; channelCount?: number };\n        workerState.initAudioDecoder\\(\n          audioData.codecType || 'opus',\n          audioData.sampleRate || 48000,\n          audioData.channelCount || 2\n        \\);\n        break;\n\n      case WorkerMessageType.SEND_TOUCH:\n        const touchData = message.data as TouchEventData;\n        workerState.sendTouchEvent\\(touchData\\);\n        break;\n\n      case WorkerMessageType.SEND_KEY:\n        const keyData = message.data as KeyEventData;\n        workerState.sendKeyEvent\\(keyData\\);\n        break;\n\n      case WorkerMessageType.SEND_CLIPBOARD:\n        const clipData = message.data as { text: string; paste?: boolean };\n        workerState.sendClipboard\\(clipData.text, clipData.paste !== false\\);\n        break;\n\n      case WorkerMessageType.HANDLE_ACTION:\n        const actionData = message.data as { action: string; data?: ArrayBuffer };\n        workerState.handleAction\\(actionData.action, actionData.data\\);\n        break;\n\n      case WorkerMessageType.CLOSE:\n        workerState.close\\(\\);\n        break;\n\n      default:\n        LoggerClient.warn\\('[StreamWorker] Unknown message type: ' + message.type\\);\n        break;\n    }\n  } catch \\(err\\) {\n    const errMsg = err instanceof Error ? err.message : String\\(err\\);\n    LoggerClient.error\\('[StreamWorker] Error handling message ' + message.type + ':', errMsg\\);\n    workerPort.postMessage\\({\n      type: WorkerMessageType.ERROR,\n      data: { message: errMsg, originalType: message.type }\n    } as WorkerMessage\\);\n  }\n};\n\n/**\n * Defines the event handler to be called when the worker receives a message that cannot be deserialized.\n */\nworkerPort.onmessageerror = \\(event: MessageEvents\\) => {\n  LoggerClient.error\\('[StreamWorker] Message deserialization failed:', event.data\\);\n};\n\n/**\n * Defines the event handler to be called when an exception occurs during worker execution.\n */\nworkerPort.onerror = \\(服务端返回错误事件，请重试。Event\\) => {\n  LoggerClient.error\\('[StreamWorker] Worker error:', event.message\\);\n};\nENDOFFILE)"
    ]
  }
}
